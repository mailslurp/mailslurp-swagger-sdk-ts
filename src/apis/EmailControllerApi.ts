/* tslint:disable */
/* eslint-disable */
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It\'s designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository 
 *
 * The version of the OpenAPI document: 6.5.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AttachmentMetaData,
    AttachmentMetaDataFromJSON,
    AttachmentMetaDataToJSON,
    DownloadAttachmentDto,
    DownloadAttachmentDtoFromJSON,
    DownloadAttachmentDtoToJSON,
    Email,
    EmailFromJSON,
    EmailToJSON,
    ForwardEmailOptions,
    ForwardEmailOptionsFromJSON,
    ForwardEmailOptionsToJSON,
    PageEmailProjection,
    PageEmailProjectionFromJSON,
    PageEmailProjectionToJSON,
    RawEmailJson,
    RawEmailJsonFromJSON,
    RawEmailJsonToJSON,
    UnreadCount,
    UnreadCountFromJSON,
    UnreadCountToJSON,
    ValidationDto,
    ValidationDtoFromJSON,
    ValidationDtoToJSON,
} from '../models';

export interface DeleteEmailRequest {
    emailId: string;
}

export interface DownloadAttachmentRequest {
    attachmentId: string;
    emailId: string;
    apiKey?: string;
}

export interface DownloadAttachmentBase64Request {
    attachmentId: string;
    emailId: string;
}

export interface ForwardEmailRequest {
    emailId: string;
    forwardEmailOptions: ForwardEmailOptions;
}

export interface GetAttachmentMetaDataRequest {
    attachmentId: string;
    emailId: string;
}

export interface GetAttachmentsRequest {
    emailId: string;
}

export interface GetEmailRequest {
    emailId: string;
    decode?: boolean;
}

export interface GetEmailHTMLRequest {
    emailId: string;
    decode?: boolean;
}

export interface GetEmailsPaginatedRequest {
    inboxId?: Array<string>;
    page?: number;
    size?: number;
    sort?: GetEmailsPaginatedSortEnum;
    unreadOnly?: boolean;
}

export interface GetRawEmailContentsRequest {
    emailId: string;
}

export interface GetRawEmailJsonRequest {
    emailId: string;
}

export interface ValidateEmailRequest {
    emailId: string;
}

/**
 * EmailControllerApi - interface
 * 
 * @export
 * @interface EmailControllerApiInterface
 */
export interface EmailControllerApiInterface {
    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * @summary Delete all emails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    deleteAllEmailsRaw(): Promise<runtime.ApiResponse<void>>;

    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * Delete all emails
     */
    deleteAllEmails(): Promise<void>;

    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * @summary Delete an email
     * @param {string} emailId ID of email to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    deleteEmailRaw(requestParameters: DeleteEmailRequest): Promise<runtime.ApiResponse<void>>;

    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * Delete an email
     */
    deleteEmail(requestParameters: DeleteEmailRequest): Promise<void>;

    /**
     * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * @summary Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    downloadAttachmentRaw(requestParameters: DownloadAttachmentRequest): Promise<runtime.ApiResponse<string>>;

    /**
     * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     */
    downloadAttachment(requestParameters: DownloadAttachmentRequest): Promise<string>;

    /**
     * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     * @summary Get email attachment as base64 encoded string (alternative to binary responses)
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    downloadAttachmentBase64Raw(requestParameters: DownloadAttachmentBase64Request): Promise<runtime.ApiResponse<DownloadAttachmentDto>>;

    /**
     * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     * Get email attachment as base64 encoded string (alternative to binary responses)
     */
    downloadAttachmentBase64(requestParameters: DownloadAttachmentBase64Request): Promise<DownloadAttachmentDto>;

    /**
     * Forward an existing email to new recipients.
     * @summary Forward email
     * @param {string} emailId ID of email
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    forwardEmailRaw(requestParameters: ForwardEmailRequest): Promise<runtime.ApiResponse<void>>;

    /**
     * Forward an existing email to new recipients.
     * Forward email
     */
    forwardEmail(requestParameters: ForwardEmailRequest): Promise<void>;

    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    getAttachmentMetaDataRaw(requestParameters: GetAttachmentMetaDataRequest): Promise<runtime.ApiResponse<AttachmentMetaData>>;

    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * Get email attachment metadata
     */
    getAttachmentMetaData(requestParameters: GetAttachmentMetaDataRequest): Promise<AttachmentMetaData>;

    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * @summary Get all email attachment metadata
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    getAttachmentsRaw(requestParameters: GetAttachmentsRequest): Promise<runtime.ApiResponse<Array<AttachmentMetaData>>>;

    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * Get all email attachment metadata
     */
    getAttachments(requestParameters: GetAttachmentsRequest): Promise<Array<AttachmentMetaData>>;

    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * @summary Get email content
     * @param {string} emailId emailId
     * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    getEmailRaw(requestParameters: GetEmailRequest): Promise<runtime.ApiResponse<Email>>;

    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * Get email content
     */
    getEmail(requestParameters: GetEmailRequest): Promise<Email>;

    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * @summary Get email content as HTML
     * @param {string} emailId emailId
     * @param {boolean} [decode] decode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    getEmailHTMLRaw(requestParameters: GetEmailHTMLRequest): Promise<runtime.ApiResponse<string>>;

    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * Get email content as HTML
     */
    getEmailHTML(requestParameters: GetEmailHTMLRequest): Promise<string>;

    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * @summary Get all emails
     * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    getEmailsPaginatedRaw(requestParameters: GetEmailsPaginatedRequest): Promise<runtime.ApiResponse<PageEmailProjection>>;

    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * Get all emails
     */
    getEmailsPaginated(requestParameters: GetEmailsPaginatedRequest): Promise<PageEmailProjection>;

    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * @summary Get raw email string
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    getRawEmailContentsRaw(requestParameters: GetRawEmailContentsRequest): Promise<runtime.ApiResponse<string>>;

    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * Get raw email string
     */
    getRawEmailContents(requestParameters: GetRawEmailContentsRequest): Promise<string>;

    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * @summary Get raw email in JSON
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    getRawEmailJsonRaw(requestParameters: GetRawEmailJsonRequest): Promise<runtime.ApiResponse<RawEmailJson>>;

    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * Get raw email in JSON
     */
    getRawEmailJson(requestParameters: GetRawEmailJsonRequest): Promise<RawEmailJson>;

    /**
     * Get number of emails unread
     * @summary Get unread email count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    getUnreadEmailCountRaw(): Promise<runtime.ApiResponse<UnreadCount>>;

    /**
     * Get number of emails unread
     * Get unread email count
     */
    getUnreadEmailCount(): Promise<UnreadCount>;

    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * @summary Validate email
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApiInterface
     */
    validateEmailRaw(requestParameters: ValidateEmailRequest): Promise<runtime.ApiResponse<ValidationDto>>;

    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * Validate email
     */
    validateEmail(requestParameters: ValidateEmailRequest): Promise<ValidationDto>;

}

/**
 * 
 */
export class EmailControllerApi extends runtime.BaseAPI implements EmailControllerApiInterface {

    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * Delete all emails
     */
    async deleteAllEmailsRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * Delete all emails
     */
    async deleteAllEmails(): Promise<void> {
        await this.deleteAllEmailsRaw();
    }

    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * Delete an email
     */
    async deleteEmailRaw(requestParameters: DeleteEmailRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.emailId === null || requestParameters.emailId === undefined) {
            throw new runtime.RequiredError('emailId','Required parameter requestParameters.emailId was null or undefined when calling deleteEmail.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}`.replace(`{${"emailId"}}`, encodeURIComponent(String(requestParameters.emailId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * Delete an email
     */
    async deleteEmail(requestParameters: DeleteEmailRequest): Promise<void> {
        await this.deleteEmailRaw(requestParameters);
    }

    /**
     * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     */
    async downloadAttachmentRaw(requestParameters: DownloadAttachmentRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
            throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling downloadAttachment.');
        }

        if (requestParameters.emailId === null || requestParameters.emailId === undefined) {
            throw new runtime.RequiredError('emailId','Required parameter requestParameters.emailId was null or undefined when calling downloadAttachment.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.apiKey !== undefined) {
            queryParameters['apiKey'] = requestParameters.apiKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/attachments/{attachmentId}`.replace(`{${"attachmentId"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"emailId"}}`, encodeURIComponent(String(requestParameters.emailId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     */
    async downloadAttachment(requestParameters: DownloadAttachmentRequest): Promise<string> {
        const response = await this.downloadAttachmentRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     * Get email attachment as base64 encoded string (alternative to binary responses)
     */
    async downloadAttachmentBase64Raw(requestParameters: DownloadAttachmentBase64Request): Promise<runtime.ApiResponse<DownloadAttachmentDto>> {
        if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
            throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling downloadAttachmentBase64.');
        }

        if (requestParameters.emailId === null || requestParameters.emailId === undefined) {
            throw new runtime.RequiredError('emailId','Required parameter requestParameters.emailId was null or undefined when calling downloadAttachmentBase64.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/attachments/{attachmentId}/base64`.replace(`{${"attachmentId"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"emailId"}}`, encodeURIComponent(String(requestParameters.emailId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DownloadAttachmentDtoFromJSON(jsonValue));
    }

    /**
     * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     * Get email attachment as base64 encoded string (alternative to binary responses)
     */
    async downloadAttachmentBase64(requestParameters: DownloadAttachmentBase64Request): Promise<DownloadAttachmentDto> {
        const response = await this.downloadAttachmentBase64Raw(requestParameters);
        return await response.value();
    }

    /**
     * Forward an existing email to new recipients.
     * Forward email
     */
    async forwardEmailRaw(requestParameters: ForwardEmailRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.emailId === null || requestParameters.emailId === undefined) {
            throw new runtime.RequiredError('emailId','Required parameter requestParameters.emailId was null or undefined when calling forwardEmail.');
        }

        if (requestParameters.forwardEmailOptions === null || requestParameters.forwardEmailOptions === undefined) {
            throw new runtime.RequiredError('forwardEmailOptions','Required parameter requestParameters.forwardEmailOptions was null or undefined when calling forwardEmail.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/forward`.replace(`{${"emailId"}}`, encodeURIComponent(String(requestParameters.emailId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ForwardEmailOptionsToJSON(requestParameters.forwardEmailOptions),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Forward an existing email to new recipients.
     * Forward email
     */
    async forwardEmail(requestParameters: ForwardEmailRequest): Promise<void> {
        await this.forwardEmailRaw(requestParameters);
    }

    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * Get email attachment metadata
     */
    async getAttachmentMetaDataRaw(requestParameters: GetAttachmentMetaDataRequest): Promise<runtime.ApiResponse<AttachmentMetaData>> {
        if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
            throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling getAttachmentMetaData.');
        }

        if (requestParameters.emailId === null || requestParameters.emailId === undefined) {
            throw new runtime.RequiredError('emailId','Required parameter requestParameters.emailId was null or undefined when calling getAttachmentMetaData.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/attachments/{attachmentId}/metadata`.replace(`{${"attachmentId"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"emailId"}}`, encodeURIComponent(String(requestParameters.emailId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AttachmentMetaDataFromJSON(jsonValue));
    }

    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * Get email attachment metadata
     */
    async getAttachmentMetaData(requestParameters: GetAttachmentMetaDataRequest): Promise<AttachmentMetaData> {
        const response = await this.getAttachmentMetaDataRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * Get all email attachment metadata
     */
    async getAttachmentsRaw(requestParameters: GetAttachmentsRequest): Promise<runtime.ApiResponse<Array<AttachmentMetaData>>> {
        if (requestParameters.emailId === null || requestParameters.emailId === undefined) {
            throw new runtime.RequiredError('emailId','Required parameter requestParameters.emailId was null or undefined when calling getAttachments.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/attachments`.replace(`{${"emailId"}}`, encodeURIComponent(String(requestParameters.emailId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AttachmentMetaDataFromJSON));
    }

    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * Get all email attachment metadata
     */
    async getAttachments(requestParameters: GetAttachmentsRequest): Promise<Array<AttachmentMetaData>> {
        const response = await this.getAttachmentsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * Get email content
     */
    async getEmailRaw(requestParameters: GetEmailRequest): Promise<runtime.ApiResponse<Email>> {
        if (requestParameters.emailId === null || requestParameters.emailId === undefined) {
            throw new runtime.RequiredError('emailId','Required parameter requestParameters.emailId was null or undefined when calling getEmail.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.decode !== undefined) {
            queryParameters['decode'] = requestParameters.decode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}`.replace(`{${"emailId"}}`, encodeURIComponent(String(requestParameters.emailId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmailFromJSON(jsonValue));
    }

    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * Get email content
     */
    async getEmail(requestParameters: GetEmailRequest): Promise<Email> {
        const response = await this.getEmailRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * Get email content as HTML
     */
    async getEmailHTMLRaw(requestParameters: GetEmailHTMLRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.emailId === null || requestParameters.emailId === undefined) {
            throw new runtime.RequiredError('emailId','Required parameter requestParameters.emailId was null or undefined when calling getEmailHTML.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.decode !== undefined) {
            queryParameters['decode'] = requestParameters.decode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/html`.replace(`{${"emailId"}}`, encodeURIComponent(String(requestParameters.emailId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * Get email content as HTML
     */
    async getEmailHTML(requestParameters: GetEmailHTMLRequest): Promise<string> {
        const response = await this.getEmailHTMLRaw(requestParameters);
        return await response.value();
    }

    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * Get all emails
     */
    async getEmailsPaginatedRaw(requestParameters: GetEmailsPaginatedRequest): Promise<runtime.ApiResponse<PageEmailProjection>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.inboxId) {
            queryParameters['inboxId'] = requestParameters.inboxId;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.unreadOnly !== undefined) {
            queryParameters['unreadOnly'] = requestParameters.unreadOnly;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PageEmailProjectionFromJSON(jsonValue));
    }

    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * Get all emails
     */
    async getEmailsPaginated(requestParameters: GetEmailsPaginatedRequest): Promise<PageEmailProjection> {
        const response = await this.getEmailsPaginatedRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * Get raw email string
     */
    async getRawEmailContentsRaw(requestParameters: GetRawEmailContentsRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.emailId === null || requestParameters.emailId === undefined) {
            throw new runtime.RequiredError('emailId','Required parameter requestParameters.emailId was null or undefined when calling getRawEmailContents.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/raw`.replace(`{${"emailId"}}`, encodeURIComponent(String(requestParameters.emailId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * Get raw email string
     */
    async getRawEmailContents(requestParameters: GetRawEmailContentsRequest): Promise<string> {
        const response = await this.getRawEmailContentsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * Get raw email in JSON
     */
    async getRawEmailJsonRaw(requestParameters: GetRawEmailJsonRequest): Promise<runtime.ApiResponse<RawEmailJson>> {
        if (requestParameters.emailId === null || requestParameters.emailId === undefined) {
            throw new runtime.RequiredError('emailId','Required parameter requestParameters.emailId was null or undefined when calling getRawEmailJson.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/raw/json`.replace(`{${"emailId"}}`, encodeURIComponent(String(requestParameters.emailId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RawEmailJsonFromJSON(jsonValue));
    }

    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * Get raw email in JSON
     */
    async getRawEmailJson(requestParameters: GetRawEmailJsonRequest): Promise<RawEmailJson> {
        const response = await this.getRawEmailJsonRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get number of emails unread
     * Get unread email count
     */
    async getUnreadEmailCountRaw(): Promise<runtime.ApiResponse<UnreadCount>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/unreadCount`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnreadCountFromJSON(jsonValue));
    }

    /**
     * Get number of emails unread
     * Get unread email count
     */
    async getUnreadEmailCount(): Promise<UnreadCount> {
        const response = await this.getUnreadEmailCountRaw();
        return await response.value();
    }

    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * Validate email
     */
    async validateEmailRaw(requestParameters: ValidateEmailRequest): Promise<runtime.ApiResponse<ValidationDto>> {
        if (requestParameters.emailId === null || requestParameters.emailId === undefined) {
            throw new runtime.RequiredError('emailId','Required parameter requestParameters.emailId was null or undefined when calling validateEmail.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/validate`.replace(`{${"emailId"}}`, encodeURIComponent(String(requestParameters.emailId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ValidationDtoFromJSON(jsonValue));
    }

    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * Validate email
     */
    async validateEmail(requestParameters: ValidateEmailRequest): Promise<ValidationDto> {
        const response = await this.validateEmailRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetEmailsPaginatedSortEnum {
    ASC = 'ASC',
    DESC = 'DESC'
}
